package com.isfootball.jdbc;

import com.isfootball.model.BasicEvent;
import com.isfootball.parser.BetSite;
import com.isfootball.parser.BetType;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.springframework.data.domain.Persistable;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * This class is generated by Spring Data Jdbc code generator.
 *
 * @author Spring Data Jdbc Code Generator
 */
public class Match implements Persistable<Long> {

    private static final Logger logger = LogManager.getLogger("parser");

    private static final long serialVersionUID = 1L;

    private volatile Long id;

    private Date matchDate;

    private Date matchDay;

    private String team1;

    private String team2;

    private String comments;

    private Boolean closed;

    private volatile transient boolean persisted;

    private Date lastUpdate;

    private ConcurrentMap<BetSite, ConcurrentMap<BetType, Bet>> bets;

    public Match() {
        bets = new ConcurrentHashMap<>();
        for (BetSite b : BetSite.values()) {
            bets.put(b, new ConcurrentHashMap<BetType, Bet>());
        }
        persisted = false;
        closed = false;
        lastUpdate = new Date();
    }

    public Match(BasicEvent e) {
        this.team1 = e.team1.toString();
        this.team2 = e.team2.toString();
        this.matchDay = e.day;
        this.matchDate = e.day;
        bets = new ConcurrentHashMap<>();
        for (BetSite b : BetSite.values()) {
            bets.put(b, new ConcurrentHashMap<BetType, Bet>());
        }
        final BetSite site = e.site;

        for (BetType b : e.bets.keySet()) {
            String val = e.bets.get(b);
            try {
                Double kVal = Double.parseDouble(val); //TODO
                BigDecimal bd = new BigDecimal(kVal);
                bd = bd.setScale(8, RoundingMode.HALF_UP);

                Bet bet = new Bet();
                bet.setSite(site.toString());
                bet.setBetVal(bd.doubleValue());
                bet.setBet(b.toString());
                bet.setUpdated(new Date());

                bets.get(site).put(b, bet);
            } catch (NumberFormatException ex) {
                logger.error("bet val ex for site: " + site.toString(), ex);
            }
        }
        persisted = false;
        closed = false;
        lastUpdate = new Date();
    }

    public Date getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(Date lastUpdate) {
        this.lastUpdate = lastUpdate;
    }

    public ConcurrentMap<BetSite, ConcurrentMap<BetType, Bet>> getBets() {
        return bets;
    }

    public void setBets(ConcurrentMap<BetSite, ConcurrentMap<BetType, Bet>> bets) {
        this.bets = bets;
    }

    public Boolean getClosed() {
        return closed;
    }

    public void setClosed(Boolean closed) {
        this.closed = closed;
    }

    public Long getId() {
        return this.id;
    }

    public boolean isNew() {
        return this.id == null;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setMatchDate(Date matchDate) {
        this.matchDate = matchDate;
    }

    public Date getMatchDate() {
        return this.matchDate;
    }

    public void setMatchDay(Date matchDay) {
        this.matchDay = matchDay;
    }

    public Date getMatchDay() {
        return this.matchDay;
    }

    public void setTeam1(String team1) {
        this.team1 = team1;
    }

    public String getTeam1() {
        return this.team1;
    }

    public void setTeam2(String team2) {
        this.team2 = team2;
    }

    public String getTeam2() {
        return this.team2;
    }

    public void setComments(String comments) {
        this.comments = comments;
    }

    public String getComments() {
        return this.comments;
    }

    public void setPersisted(Boolean persisted) {
        this.persisted = persisted;
    }

    public Boolean getPersisted() {
        return this.persisted;
    }

    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

	/* START Do not remove/edit this line. CodeGenerator will preserve any code between start and end tags.*/

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof Match)) {
            return false;
        }

        Match m = (Match) o;

        if (m.getId() == this.id) {
            return true;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return id.intValue();
    }

    /* END Do not remove/edit this line. CodeGenerator will preserve any code between start and end tags.*/

}